<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>FastAPI Sync Test</title>
  <script>
    // Unregister any existing service workers that might interfere
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations().then(function(registrations) {
        for(let registration of registrations) {
          registration.unregister();
          console.log('Service worker unregistered');
        }
      });
    }
  </script>
</head>
<body>
  <h2>WebSocket Sync Test</h2>

  <button id="connectBtn" onclick="connect()">Connect</button>
  <button id="disconnectBtn" onclick="disconnect()" disabled>Disconnect</button>
  <br><br>

  <button onclick="sendPlay()">‚ñ∂Ô∏è Play</button>
  <button onclick="sendPause()">‚è∏Ô∏è Pause</button>
  <button onclick="sendSeek()">‚è© Seek (to 60s)</button>
  <button onclick="sendSetTrack()">üéµ Set Track</button>
  <br><br>

  <button onclick="sendPing()">Ping</button>
  <button onclick="sendGetState()">Get State</button>

  <br><br>
  <hr>
  <h3>Audio Player</h3>
  <label>
    <input type="checkbox" id="syncCheckbox" onchange="handleSyncToggle()"> Sync to Server
  </label>
  <br>
  <label>
    <input type="checkbox" id="hostCheckbox" onchange="handleHostToggle()"> Host Mode
  </label>
  <br><br>
  <audio id="audioPlayer" controls>
    Your browser does not support the audio element.
  </audio>
  <br>
  <div id="audioStatus"></div>

  <h3>Messages: <button onclick="clearLogs()">Clear Logs</button></h3>
  <pre id="log"></pre>

  <script>
    let ws = null;
    let logBox = document.getElementById("log");
    let audioPlayer = null;
    let isSynced = false;
    let isHost = false;
    let applyingServerUpdate = false; // Flag to prevent feedback loops
    let serverOffset = 0; // Client time - Server time (for sync calculations)
    let lastServerState = null; // Store last received server state for sync-on-enable

    function log(message) {
      logBox.textContent += message + "\n";
      logBox.scrollTop = logBox.scrollHeight;
    }

    function clearLogs() {
      logBox.textContent = "";
    }

    // Initialize audio player when page loads
    window.addEventListener("DOMContentLoaded", () => {
      audioPlayer = document.getElementById("audioPlayer");
      setupAudioListeners();
      updateAudioStatus();
    });

    function setupAudioListeners() {
      // If host, send play command
      audioPlayer.addEventListener("play", () => {
        if (isHost && !applyingServerUpdate && ws?.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: "play" }));
          log("‚û°Ô∏è [Host] Sent: play");
        }
      });

      // If host, send pause command
      audioPlayer.addEventListener("pause", () => {
        if (isHost && !applyingServerUpdate && ws?.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: "pause" }));
          log("‚û°Ô∏è [Host] Sent: pause");
        }
      });

      audioPlayer.addEventListener("seeked", () => {
        // If host, send seek command
        if (isHost && !applyingServerUpdate && ws?.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: "seek", payload: { position: audioPlayer.currentTime } }));
          log("‚û°Ô∏è [Host] Sent: seek ‚Üí " + audioPlayer.currentTime.toFixed(2) + "s");
        }
      });

      // Update status display
      audioPlayer.addEventListener("timeupdate", () => {
        if (isSynced) {
          updateAudioStatus();
        }
      });
    }

    function handleSyncToggle() {
      const syncCheckbox = document.getElementById("syncCheckbox");
      isSynced = syncCheckbox.checked;
      
      if (isSynced) {
        // Sync enabled - request current state from server
        log("üîÑ Sync enabled");
        if (ws?.readyState === WebSocket.OPEN) {
          // Request current state from server
          ws.send(JSON.stringify({ type: "get_state" }));
          log("‚û°Ô∏è Sent: get_state");
        }
        // Apply last known server state if available (while waiting for fresh state)
        if (lastServerState) {
          handleServerUpdate(lastServerState);
        }
      } else {
        log("üîì Sync disabled");
      }
      updateAudioStatus();
    }

    function handleHostToggle() {
      const hostCheckbox = document.getElementById("hostCheckbox");
      isHost = hostCheckbox.checked;
      
      if (isHost) {
        log("üéÆ Host mode enabled - your actions will broadcast to all clients");
      } else {
        log("üë§ Host mode disabled");
      }
      updateAudioStatus();
    }

    function updateAudioStatus() {
      const statusDiv = document.getElementById("audioStatus");
      let status = `Time: ${audioPlayer?.currentTime.toFixed(2) || 0}s / ${audioPlayer?.duration.toFixed(2) || 0}s | `;
      status += isSynced ? "üü¢ Synced" : "‚ö™ Not Synced";
      if (isHost) {
        status += " | üéÆ Host";
      }
      statusDiv.textContent = status;
    }

    function setAudioSource(trackUrl) {
      if (!audioPlayer || !trackUrl) return;
      
      const currentSrc = audioPlayer.src;
      if (currentSrc === trackUrl) {
        // Already loaded this track
        return;
      }
      
      // Set the audio source directly
      audioPlayer.src = trackUrl;
      audioPlayer.load();
      log("üéµ Audio source set to: " + trackUrl);
    }

    function handleServerUpdate(data) {
      if (!audioPlayer) return;
      
      applyingServerUpdate = true;
      
      try {
        if (data.type === "state_sync") {
          // Initial sync - apply current server state
          const state = data.payload;
          if (state.track) {
            // Set audio source from server
            setAudioSource(state.track);
            
            // Wait for audio metadata to load, then sync position
            const syncPosition = () => {
              if (state.is_playing && state.start_time) {
                // Calculate current position: server_time - start_time
                const serverTime = data.server_time;
                const currentPos = serverTime - state.start_time;
                audioPlayer.currentTime = Math.max(0, currentPos);
                audioPlayer.play().catch(() => {});
                log("üîÑ [Sync] Playing from position: " + currentPos.toFixed(2) + "s");
              } else {
                // Paused - use stored position
                audioPlayer.currentTime = state.position || 0;
                audioPlayer.pause();
                log("üîÑ [Sync] Paused at position: " + (state.position || 0).toFixed(2) + "s");
              }
            };
            
            // If metadata already available, sync immediately
            if (audioPlayer.readyState >= 1) {
              syncPosition();
            } else {
              // Wait for metadata to load
              audioPlayer.addEventListener("loadedmetadata", syncPosition, { once: true });
            }
            
            serverOffset = Date.now() / 1000 - data.server_time;
          } else {
            // No track set on server - preserve current audio state
            // Don't change playback state, just store server offset
            serverOffset = Date.now() / 1000 - data.server_time;
            log("üîÑ [Sync] Enabled (no track on server, preserving current state)");
          }
        } else if (data.type === "play") {
          // Server says play - calculate position from start_time
          if (data.payload && data.payload.start_time) {
            const serverTime = data.server_time;
            const currentPos = serverTime - data.payload.start_time;
            audioPlayer.currentTime = Math.max(0, currentPos);
            audioPlayer.play().catch(() => {});
            log("‚ñ∂Ô∏è [Sync] Play from: " + currentPos.toFixed(2) + "s");
            serverOffset = Date.now() / 1000 - serverTime;
          }
        } else if (data.type === "pause") {
          // Server says pause - pause at specified position
          if (data.payload && typeof data.payload.position === "number") {
            audioPlayer.currentTime = data.payload.position;
            audioPlayer.pause();
            log("‚è∏Ô∏è [Sync] Pause at: " + data.payload.position.toFixed(2) + "s");
          }
        } else if (data.type === "seek") {
          // Server says seek - move to position
          if (data.payload && typeof data.payload.position === "number") {
            const wasPlaying = !audioPlayer.paused;
            audioPlayer.currentTime = data.payload.position;
            if (wasPlaying) {
              audioPlayer.play().catch(() => {});
            }
            log("‚è© [Sync] Seek to: " + data.payload.position.toFixed(2) + "s");
          }
        } else if (data.type === "set_track") {
          // Track changed
          if (data.payload && data.payload.track) {
            setAudioSource(data.payload.track);
            audioPlayer.currentTime = 0;
            audioPlayer.pause();
            log("üéµ [Sync] Track set, reset position");
          }
        } else if (data.type === "pong") {
          // Calculate server offset for future sync calculations
          serverOffset = Date.now() / 1000 - data.server_time;
        }
      } catch (error) {
        log("‚ö†Ô∏è Error applying server update: " + error);
      } finally {
        // Small delay to ensure audio events have processed
        setTimeout(() => {
          applyingServerUpdate = false;
        }, 100);
      }
      
      updateAudioStatus();
    }

    function connect() {
      const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
      const host = window.location.hostname || "localhost";
      const port = 8000;
      const wsUrl = `${protocol}//${host}:${port}/ws`;

      ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        log("‚úÖ Connected to " + wsUrl);
        document.getElementById("connectBtn").disabled = true;
        document.getElementById("disconnectBtn").disabled = false;
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          log("üì© " + JSON.stringify(data, null, 2));
          
          // Store state_sync messages for later use
          if (data.type === "state_sync") {
            lastServerState = data;
            // Always set audio source from server (even when not synced)
            if (data.payload && data.payload.track) {
              setAudioSource(data.payload.track);
            }
          }
          
          // Handle server updates when synced
          if (isSynced && data.type) {
            handleServerUpdate(data);
          }
          
          // Handle set_track even when not synced (to update audio source)
          if (!isSynced && data.type === "set_track" && data.payload && data.payload.track) {
            setAudioSource(data.payload.track);
          }
        } catch {
          log("üì© " + event.data);
        }
      };

      ws.onclose = () => {
        log("‚ùå Disconnected");
        document.getElementById("connectBtn").disabled = false;
        document.getElementById("disconnectBtn").disabled = true;
      };

      ws.onerror = (err) => {
        log("‚ö†Ô∏è Error: " + err);
      };
    }

    function disconnect() {
      if (ws) ws.close();
    }

    function sendPlay() {
      if (ws?.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "play" }));
        log("‚û°Ô∏è Sent: play");
      }
    }

    function sendPause() {
      if (ws?.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "pause" }));
        log("‚û°Ô∏è Sent: pause");
      }
    }

    function sendSeek() {
      if (ws?.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "seek", payload: { position: 60 } }));
        log("‚û°Ô∏è Sent: seek ‚Üí 60s");
      }
    }

    function sendSetTrack() {
      if (ws?.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "set_track", payload: { track: "https://yhoyscexuxnouexhcndo.supabase.co/storage/v1/object/public/jukebox-tracks/zx6NkXvzrNc.webm" } }));
        log("‚û°Ô∏è Sent: set_track");
      }
    }

    function sendPing() {
      if (ws?.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "ping", client_time: Date.now() / 1000 }));
        log("‚û°Ô∏è Sent: ping");
      }
    }

    function sendGetState() {
      if (ws?.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "get_state" }));
        log("‚û°Ô∏è Sent: get_state");
      }
    }
  </script>
</body>
</html>
